## Index
 - 테이블의 조회 속도를 높여주는 자료 구조
 - 컬럼(컬럼들)의 값과 헤대당 레코드가 저장된 주소를 key-value로 인덱스 생성
 - 키 값을 기준으로 항상 정렬을 유지한다.
   - 정렬을 유지하기 때문에 저장, 삭제, 변경 작업이 더 느려짐

### 랜덤 I/O 와 순차 I/O
 - 순차 I/O 가 랜덤 I/O 보다 훨씬 빠르다.
 - 인덱스 레인지 스캔은 랜덤 I/O
 - 풀 테이블 스캔은 순차 I/O
 - 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할 때도 있음

### Primary Key

### Secondary Key(보조 키)
 - Primary Key를 제외한 나머지 모든 인덱스

### 저장 방식
 - B-Tree(Binary) 인덱스
   - 대부분의 경우 B-Tree 사용
 - Hash 인덱스
   - Prefix 검색, Range 검색 지원하지 않음
   - 주로 메모리 기반 DB에서 사용

### B-Tree 구조 및 특성
 - 루트 노드 -> 브랜치 노드 -> 리프 노드
 - 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아갈 때
   - 세컨더리 인덱스의 리프 노드가 가리키는 값은 레코드의 주소가 아니고 프라이머리 키 값임
   - 프라이머리 키 값으로 프라이머리 키 인덱스를 다시 조회해서 프라이머리 키 인덱스의 리프 노드에 도달하면 그때서야 데이터 조회 가능
     - 왜 이렇게 했나? 두번 조회로 더 느려지지 않나?
       - 느려짐, 하지만 데이터의 위치가 변경되었을 때 프라이머리 키 인덱스의 리프 노드만 수정하면 된다는 장점이 있음, 트레이드 오프!
 - 자식 노드 개수는 가변적임, 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.
   - InnoDB 스토리지 엔진의 페이지 기본 크기값은 16KB
   - 인덱스의 키가 16 바이트라고 가정하고, 자식 노드주소가 12바이트라고 가정하면
   - 16 * 1024 / (16 + 12) = 585개 만큼의 자식 노드를 가질 수 있다
   - 이렇기 때문에 인덱스의 키 크기에 제한을 걸어두는 것
   - 인덱스 키 크기가 커지면 커질수록 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, B-Tree 깊이도 더 깊어져서 디스크 읽기가 더 많이 필요해짐

### Index Range Scan
 - 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다(index seek)
 - 위에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다(index scan)
 - 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
   - 이 단계에서 랜덤 I/O가 발생하기 때문에 인덱스를 통해 읽어야 할 데이터 레코드가 전체의 20~25%를 넘을 경우 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 효율적이다(순차 I/O)

### 커버링 인덱스
 - `select column A, B` 쿼리 실행 시, Column A & B 가 모두 index 테이블에 있어서 데이터 파일로부터 직접 읽을 필요가 없는 경우를 `커버링 인덱스` 라고 한다.