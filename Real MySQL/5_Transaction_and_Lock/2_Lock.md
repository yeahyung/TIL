## Lock
 - MySQL에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.

### MySQL 엔진 잠금
 - 테이블 데이터 동기화를 위한 `테이블 락`과 테이블 구조를 잠그는 `메타데이터 락`, 그리고 사용자의 필요에 맞게 사용할 수 있는 `네임드 락` 잠금 기능을 제공한다.

#### 글로벌 락
 - MySQL 에서 제공하는 잠금 중 가장 범위가 크다.
 - 한 세션에서 글로벌 락을 획득하면, 다른 세션에서 `SELECT`를 제외한 대부분의 DDL, DML 쿼리는 대기 상태로 남음
   - 작업 대상 테이블, 데이터베이스가 다르더라고 영향을 받음
 - 모든 작업을 중지시키기 때문에 함부로 하면 안됨, 좀 더 가벼운 역할의 글로벌 락 필요 => 백업 락
   - 백업 락은 일반적인 테이블의 데이터 변경은 허용함
     - 데이터 백업을 한다고 가정하면 레플리카 서버에서 실행되는데, 이때 글로벌 락을 획득하면 데이터가 백업되는 시간동안 레플리카 서버에 데이터 복제가 멈춤
     - => 이러한 상황에서 글로벌 락이 아닌 백업 락 사용

#### 테이블 락
 - 개별 테이블 단위로 설정되는 잠금
 - InnoDB 테이블에서는 DML 쿼리에서는 테이블 락이 설정되지 않고(레코드 락이 있기 때문에) DDL 쿼리에서는 테이블 락이 설정된다.
 - MyISAM, MEMORY 테이블에서는 데이터를 변경하는 쿼리(DML, DDL) 에서 테이블 락이 설정된다.

#### 네임드 락
 - 대상이 테이블이나 레코드 또는 `AUTO_INCREMENT`와 같은 데이터베이스 객체가 아니라 단순 사용자가 지정한 문자열에 대해 잠금을 획득하고 반납하는 형태

#### 메타데이터 락
 - 데이터베이스 객체(테이블, 뷰 등)의 이름이나 구조를 변경하는 경우 획득하는 잠금
 - 명시적으로 획득하거나 해제할 수 있지 않음, `RENAME` 등의 쿼리 실행 시 자동으로 획득됨

### InnoDB 스토리지 엔진 잠금
 - 레코드 기반의 잠금 방식
 - 레코드 락 뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 `갭(GAP) 락`이라는 것도 존재

#### 레코드 락
 - 레코드 자체만(InnoDB 에서는 사실 레코드 자체가 아니라 인덱스의 레코드)을 잠그는 것
   - 인덱스가 하나도 없더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금 설정함

#### 갭 락
 - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT) 되는 것을 제어하는 것

#### 넥스트 키 락
 - 레코드 락 + 갭 락 = 넥스트 키 락
 - 넥스트 키 락과 갭 락의 주 목적은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버(프라이머리)에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것
 - STATEMENT 포맷의 바이너리 로그에만 사용되며 ROW 포맷으로 사용할 경우 락을 줄일 수 있음

#### 자동 증가 락
 - `AUTO_INCREMENT` 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 중복되지 않고 순서대로 증가하는 일련번호 값을 제공하기 위해 `AUTO_INCREMENT 락`이라는 테이블 수준의 잠금을 제공
   - MySQL 5.0 이하 버전(혹은 `innodb_autoinc_lock_mode=0`일 때의 방식)
 - `innodb_autoinc_lock_mode=1`
   - 단순히 한 건 또는 여러 건의 레코드를 INSERT하는 작업중에서 MySQL 서버가 레코드의 건수를 정확히 예측할 수 있을때는 자동 증가 락을 사용하지 않고 래치(뮤텍스)를 이용해 처리함
   - 대량 INSERT되는 경우, InnoDB 스토리지 엔진은 여러 개의 자동 증가 값을 한 번에 할당받아서 INSERT 레코드에 사용한다.
     - 단, 한 번에 할당받은 자동 증가 값이 INSERT 레코드보다 클 경우, 해당 값은 폐기되어 다음 INSERT 작업에서 자동 증가 값이 연속적이지 않을 수 있음
     - 하나의 대량 INSERT 작업에서는 연속적이나 INSERT 작업 간에는 연속적이지 않을 수 있다.
       - [1, 2, 3, 4, 5], [10, 11, 12, 13, 14] ... 
 - `innodb_autoinc_lock_mode=2`(MySQL 8.0 버전부터 Default)
   - 절대 자동 증가 락을 걸지 않고 래치(뮤텍스)만 사용 
   - 자동 증가 값이 유니크함만 보장하지 연속된 값을 보장하지 않음

### 인덱스와 잠금
 - InnoDB 에서 레코드 락은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식!
   - 즉, 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다
```
first_name = index

SELECT COUNT(*) FROM employess WHERE first_name = 'Georgi'; => 253 rows
SELECT COUNT(*) FROM employess WHERE first_name = 'Georgi' AND last_name = 'Klassen'; => 1 row

UPDATE employess SET hire_date=NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';
```
 - 위의 쿼리에서 인덱스를 이용할 수 있는 조건은 `first_name = 'Georgi'` 이기 때문에 한 건의 레코드를 업데이트하기 위해 253 건의 레코드가 모두 잠긴다.
 - 검색 조건에 사용할 수 있는 인덱스가 없다면 full scan => 모든 레코드가 잠김