## InnoDB 스토리지 엔진 아키텍쳐

### 프라이머리 키에 의한 클러스터링
 - InnoDB의 모든 테이블은 기본적으로 `프라이머리 키`를 기준으로 클러스터링되어 저장된다.
   - `프라이머리 키` 값의 순서대로 디스크에 저장된다 
   - 세컨터리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함
     - MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음 / 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소값을 가짐

### 외래 키 지원
 - InnoDB 스토리지 엔진에서만 지원하는 기능
 - 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 두 테이블에 데이터가 있는지 체크하는 작업이 필요하기 때문에 잠금이 여러 테이블로 전파되어 데드락이 발생할 확률이 높음

### MVCC(Multi Version Concurrency Control)
 - 레코드 레벨의 트랜잭션을 지원하는 DBMS 에서 제공하는 기능
 - 잠금을 사용하지 않는 일관된 읽기를 제공함(Undo log를 통해 구현)
 - Multi Version = 하나의 레코드에 대한 여러개의 버전이 동시에 관리된다는 의미
 - ex) Update 쿼리 실행 시, `InnoDB` 버퍼풀에는 새로운 값의 데이터로 업데이트되고 디스크의 데이터 파일에는 체크포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트됐을 수도 있고 아닐수도 있음(InnoDB가 ACID를 보장하기 때문에 일반적으로 InnoDB의 버퍼풀과 데이터 파일은 동일한 상태라고 가정해도됨)
   - `Undo log`에 이전 데이터가 복사됨 
   - 아직 `Commit`이나 `Rollback`이 되지 않은 상태에서 사용자가 해당 레코드를 조회하면 어디에 있는 데이터를 조회하는가?
     - `Isolation Level`에 따라 다르다.
       - `READ_UNCOMMITTED`인 경우, InnoDB 버퍼풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환
       - `READ_COMMITTED` 혹은 그 이상의 격리 수준인 경우에는 `Undo log`의 데이터를 반환
   - `Rollback`이 된 경우, `Undo log`의 데이터는 사라지나 `Commit`이 된 경우엔 바로 사라지지 않고 `Undo log` 영역을 필요로 하는 트랜잭션이 더는 없을 때 삭제됨

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
 - InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행할 수 있음
 - 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 `SELECT` 작업을 방해하지 않는다 => `잠금 없는 일관된 읽기`

### 자동 데드락 감지
 - InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프 형태로 관리
 - 별도의 데드락 감지 스레드를 통해 주기적으로 잠금 대기 목록 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 강제로 종료함
   - 어떤 트랜잭션을 종료할지 기준은 트랜 잭션의 `Undo log`의 양(더 적게 가진 트랜잭션이 롤백 대상이 됨)
 - 이 기능 또한 CPU 자원 소모를 할 수 있고 감지 시 작므 상태가 변경되지 않도록 잠금 목록이 저장된 리스트를 또 잠금을 걸어야 함 => 성능 저하 유발
 - `innodb_dealock_detect` 시스템 변수를 통해 on/off 가능
   - off 해놓을 경우 데드락에서 빠져나오지 못하기 때문에 `innodb_lock_wait_timeout` 설정을 통해 잠금을 설정한 시간 동안 획득하지 못하면 실패 처리하도록 설정해줘야 한다.

### 자동화된 장애 복구
 - InnoDB 스토리지 엔진은 MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 복구 작업을 자동으로 진행함

### InnoDB 버퍼 풀
 - InnoDB 스토리지 엔진에서 가장 핵심적인 부분
 - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
 - 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할
   - 일반적인 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킴
   - => 버퍼 풀을 통해 변경된 데이터를 모아서 처리하여 랜덤한 디스크 작업의 횟수를 줄일 수 있음

#### 버퍼 풀의 크기 설정
#### 버퍼 풀의 구조
 - InnoDb 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장한다.
 - 데이터를 찾는 과정
```agsl
1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
  A. InnoDB 어댑티브 해시 인덱스를 이용해 페이지 검색
  B. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지 검색
  C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼풀에서 제거됨, 쿼리에 의해 사용되면 나이가 초기화됨
5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
```

### 언두 로그
 - InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다.
   - 백업된 데이터를 `언두 로그`라고 한다.
 - **트랜잭션 보장**
 - **격리 수준 보장**
 - INSERT 문장으로 인한 언두 로그와 UPDATE, DELETE 문장으로 인한 언두 로그는 별도로 관리됨(INSERT는 MVCC를 위해 사용되지 않기 때문에)

### 체인지 버퍼
 - 인덱스를 업데이트 하는 작업은 디스크를 랜덤하게 읽는 작업이 필요함
 - InnoDB에서는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하기만 디스크로부터 읽어와야 한다면 이를 즉시 실행하지 않고 임시 공간(체인지 버퍼)에 저장하고 `머지 스레드`에 의해 디스크에 반영됨

### 리두 로그 및 로그 버퍼
 - 일반적으로 데이터 변경 내용을 데이터 파일에 바로 반영하기 보다는 로그로 먼저 기록한다.
   - 읽기 성능을 고려한 자료 구조로 데이터가 저장되어 있기 때문에 데이터 파일에 반영은 비용이 많이 든다.
 - MySQL 서버가 비정상 종료되면 리두 로그의 내용을 토대로 데이터 파일을 복구한다.
 - 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 하는 것을 권장한다.
   - 하지만 일면, 트랜잭션이 커밋될 때 마다 리두 로그를 디스크에 기록하기 때문에 많은 부하를 유발한다.
   - 따라서, 일정 주기로 디스크에 동기화할 수 있는 `innodb_flush_log_at_trx_commit` 시스템 변수를 제공한다.

### 어댑티브 해시 인덱스
 - InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
 - 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있도록 함
   - 데이터 페이지 위치를 메모리 내에서 빠르게 얻을 수 있는 기능이지(B-Tree 루트 노드를 거쳐 브랜치 노드, 리프 노드까지 찾아가는 과정이 필요없어짐), 데이터를 빠르게 조회하는 것과는 관계가 없다. 
 - 어댑티브 해시 인덱스가 성능 향상에 도움이 되는 경우
   - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
   - 동등 조건 검색(동등 비교, IN 연산자)이 많은 경우
   - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
 - 어댑티브 해시 인덱스가 성능 향상에 도움이 되지 않는 경우
   - 디스크 읽기가 많은 경우
   - 특정 패턴의 쿼리가 많은 경우(JOIN, LIKE)
   - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
   - 어댑티브 해시 인덱스 또한 저장 공간인 메모리를 사용하며, 인덱스 관리에 리소스가 사용됨