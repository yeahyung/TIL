## 연관관계 매핑

### 단방향, 양방향
 - 테이블
   - 외래키 하나로 양쪽 조인 가능
   - 테이블에서 사실 방향이라는 개념은 없음
 - 객체
   - 참조용 필드가 있는 쪽으로만 참조 가능
   - 한쪽만 참조하면 단방향
   - 양쪽이 서로 참조하면 양방향
   - 연관 관계의 주인: 외래 키를 관리하는 참조
     - 외래 키가 있는 곳이 주인!
       - MEMBER(MEMBER_ID(PK), TEAM_ID(FK)), TEAM(TEAM_ID(PK)) 일 경우, MEMBER 가 주인!
       - TEAM의 경우 `mappedBy` 적용

### 일대일 매핑(OneToOne)
 - 주 테이블에 외래 키
   - 주 객체가 대상 객체의 참조를 가지는 것처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
   - 객체지향 개발자 선호, JPA  매핑 편리
   - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
   - 단점: 값이 없으면 외래 키에 null 허용
 - 대상 테이블에 외래 키
   - 대상 테이블에 외래 키 존재
   - 전통적인 데이터베이스 개발자 선호
   - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
   - 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨

### 일대다 매핑(OneToMany, 1:N)
 - Team -> Member 관계
 - `일대다 단방향`에서는 `일(1)`이 연관 관계의 주인
   - `다(N)` 쪽에 외래키가 있지만 예외적인 구조(원래 연관 관계의 주인은 외래 키가 있는 곳)
   - 연관 관계 관리를 위해 추가로 `UPDATE SQL` 쿼리가 실행됨(Team에 Member 추가하는 경우, Member에 TEAM_ID 컬럼을 업데이트해야함)
     - 따라서, 단방향일 경우 권장하지 않는 모델(다대일 양방향 매핑을 권장)
   - `@JoinColumn`을 사용해야함, 그렇지 않으면 조인 테이블 방식을 사용(TEAM_MEMBER 별도 테이블을 만들어서 관리함)
 - `일대다 양방향`
   - 공식적으로 존재하지 않음, `다대일 양방향`을 사용하자.

### 다대일(ManyToOne, N:1)
 - Member -> Team 관계
 - `다대일 단방향`
   - 가장 많이 사용되는 연관 관계
 - `다대일 양방향`
   - 외래 키가 있는 쪽이 연관 관계의 주인
   - 양쪽을 서로 참조하도록 개발
    
### 다대다(ManyToMany, N:M)
 - 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음, 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어야함
 - 편리해보이지만 실무에서 사용하지 않음, 연결 테이블이 단순히 연결만 하고 끊나지 않음
   - 부수적으로 추가적인 컬럼이 필요한 케이스도 있음
 - 다대다를 구현하기 위해 연결 테이블용 엔티티를 추가하고, 추가된 엔티티에 대하여 OneToMany, ManyToOne 관계로 해결

## 상속관계 매핑
 - 관계형 데이터베이스는 상속 관계라는 개념이 없음
 - 객체에서 상속 관계를 구현하는 방법
   - `조인 전략`, `단일 테이블 전략`, `구현 클래스마다 테이블 전략`
   - Album, Movie, Book extends Item 인 상황으로 가정
     - 조인 전략: 부모 클래스에 해당하는 내용을 별도의 테이블로 분리하여 사용하는 개념(/w FK)
       - Item을 별도 테이블로 설정 & Album, Movie, Book 에서 ITEM_ID를 FK로 갖도록 설정
       - 장점: 테이블 정규화, 저장공간 효율화, 외래 키 참조 무결성 제약조건 활용 가능
       - 단점: 조회 시 조인을 많이 사용하여 성능 저하, 조회 쿼리 복잡, 저장 시 INSERT 쿼리 2회 호출
     - 단일 테이블 전략: 하나의 테이블에 모든 내용을 다 컬럼으로 설정(자손 클래스의 필드도 모두 컬럼화)
       - Album, Movie, Book, Item에 해당하는 필드를 하나의 테이블에 모두 컬럼으로 설정 
       - 장점: 조회 쿼리가 단순하며 조인이 필요없어 성능이 빠름
       - 단점: 자식 엔티티가 매핑한 컬럼은 모두 null 허용, 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음 -> 상황에 따라 조회 성능이 오히려 느려질 수 있음
     - 구현 클래스마다 테이블 전략: 자손 클래스 + 부모 클래스의 필드로 전부 테이블을 만듬, 추천 X
       - Album: Album + Item, Movie: Movie + Item
       - 장점: 서브 타입을 명확하게 구분해서 처리할 때 효과적, not null 제약 조건 사용 가능
       - 단점: 여러 자식 테이블을 함께 조회하기 어려움 + 느림(UNION 쿼리 필요)

### MappedSuperclass
 - 공통 매핑 정보가 필요할 때 사용(등록일, 수정일 등)
 - @Entity 클래스는 @Entity나 @MappedSuperclass로 지정한 클래스만 상속 가능
 - 